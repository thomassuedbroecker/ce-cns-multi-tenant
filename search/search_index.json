{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"UNDER CONSTRUCTION \u00b6 Objective \u00b6 Getting started to implement an example microservices based application for multi tenancy. A basic use case for the example usage needs to be defined. The starting point from the technical and usage perspective is this workshop Get started to deploy a Java Microservices application to Code Engine . Planned next steps \u00b6 The plan will be changed, if needed. Task State Comments Get it working on the local machine done simplified for the basic Use Case Deploy it to Code Engine open Maybe this will be finished Redefine the use case and technology canceled Moved to a different github project Plan to implement with redefined use case and technology canceled Moved to a different project github project Basic Use Case \u00b6 Short Description \u00b6 Get articles displayed based on your email domain, user role and user authentication and authorization. Basic Flow \u00b6 Insert email address Based on the domain of your email address you are routed to the right tenant (examples blog.de and blog.com ) Login to the right realm on the identity and access management system The articles are displayed according to the user role and tenant. Here an example basic flow implementation at the local machine. Architecture \u00b6 Basic dependencies (local machine) The gif shows a basic overview of following sequence: Invoke web-app-select on port 8080 and insert your email to select the domain for the tenant ((blog.de == tenantA) and (blog.com == tenantA)) The related webfrontend for blog.de is invoked, it's web-app-tenant-a ( port 8081 ) that redirects to the right Keycloak realm (tenant-A) which provides the login and returns the access-token. We use that token to access the web-api microservice ( port 8083 ). Therefor we invoke the web-api REST endpoint related to the right tenant (realm), in this case it's tenant-a. ( user:alice;role:user in both realms) The microservice web-api uses the the functionalities for multitenancy provided by Quarkus security openID connect multitenancy to extract the invoked endpoint from the rootcontext and set the right configuration for the given tenant, that means in this case for the Keycloak realm . Quarkus also does the validation of the access token at right Keycloak realm and forwards the given access-token to the microservice articles, by using the right REST endpoint for the given tenant. The articles microservice does the same validation as web-api using Quarkus and uses the right query to provide the needed articles data from the Cloudant database. In this example we use: Three web applications web-app-select (extract domain) web-app-tenant-a (connect to tenant a) web-app-tenant-b (connect to tenant b) Two microservices web-api (react based on given tenant) articles (react based on given tenant) One Identity and Access Management system Keycloak with two custom realms (optional) One database service on IBM Cloud Cloudant with one Database Technologies \u00b6 The example application currently uses following technologies. Identity and Access Management Keycloak Database Cloudant Multi Tenancy Quarkus Security OpenID Connect Multi Tenancy for the Java microservices implementation Microservies Quarkus Java Web frontends: Vue.js JavaScript Example setup automation Bash Run the current example locally \u00b6 Prerequisites \u00b6 Environment \u00b6 Local OS: Mac OS Visual Studio Code (optional) You need to you have installed on you MacOS: Java: openjdk version \"11.0.11\" Docker Desktop: \"3.4\" Apache Maven: \"3.8.1\" Vue.js: vue/cli \"4.5.13\" Steps \u00b6 You should be able to simply run the example locally. Step 1: Clone the project \u00b6 git clone https://github.com/thomassuedbroecker/ce-cns-multi-tenant cd ce-cns-multi-tenant/CE Step 2: Start the example with a bash script \u00b6 bash local-start-tenant.sh This bash script will start seven terminals: Keycloak (port 8282) Web-App select (port 8080) Web-App tenant A (port 8081) Web-App tenant B (port 8082) Web-API microservice (port 8083) Articles microservice (port 8084) Auto configuration of Keycloak ( waits 1 min before the configuration starts ) The image below shows the terminal sessions: two browser sessions Web-App select http://localhost:8080/ Keycloak admin http://localhost:8282/ (admin/admin) Step 3: Select a tenant by inserting a email address in the Web-App select \u00b6 Use following: alice@blog.de for tenant a alice@blog.com for tenant b Step 4: Login to tenant a or tenant b \u00b6 Use following: User: alice Password: alice Step 5: Logout from tenant a or tenant b \u00b6 Because this will clear the saved cookie in the browser from Keycloak . Step 6: Login to Keycloak master realm \u00b6 Use following: User: admin Password: admin Verify the two realm configurations tenant-a and tenant-b.","title":"Overview"},{"location":"#under-construction","text":"","title":"UNDER CONSTRUCTION"},{"location":"#objective","text":"Getting started to implement an example microservices based application for multi tenancy. A basic use case for the example usage needs to be defined. The starting point from the technical and usage perspective is this workshop Get started to deploy a Java Microservices application to Code Engine .","title":"Objective"},{"location":"#planned-next-steps","text":"The plan will be changed, if needed. Task State Comments Get it working on the local machine done simplified for the basic Use Case Deploy it to Code Engine open Maybe this will be finished Redefine the use case and technology canceled Moved to a different github project Plan to implement with redefined use case and technology canceled Moved to a different project github project","title":"Planned next steps"},{"location":"#basic-use-case","text":"","title":"Basic Use Case"},{"location":"#short-description","text":"Get articles displayed based on your email domain, user role and user authentication and authorization.","title":"Short Description"},{"location":"#basic-flow","text":"Insert email address Based on the domain of your email address you are routed to the right tenant (examples blog.de and blog.com ) Login to the right realm on the identity and access management system The articles are displayed according to the user role and tenant. Here an example basic flow implementation at the local machine.","title":"Basic Flow"},{"location":"#architecture","text":"Basic dependencies (local machine) The gif shows a basic overview of following sequence: Invoke web-app-select on port 8080 and insert your email to select the domain for the tenant ((blog.de == tenantA) and (blog.com == tenantA)) The related webfrontend for blog.de is invoked, it's web-app-tenant-a ( port 8081 ) that redirects to the right Keycloak realm (tenant-A) which provides the login and returns the access-token. We use that token to access the web-api microservice ( port 8083 ). Therefor we invoke the web-api REST endpoint related to the right tenant (realm), in this case it's tenant-a. ( user:alice;role:user in both realms) The microservice web-api uses the the functionalities for multitenancy provided by Quarkus security openID connect multitenancy to extract the invoked endpoint from the rootcontext and set the right configuration for the given tenant, that means in this case for the Keycloak realm . Quarkus also does the validation of the access token at right Keycloak realm and forwards the given access-token to the microservice articles, by using the right REST endpoint for the given tenant. The articles microservice does the same validation as web-api using Quarkus and uses the right query to provide the needed articles data from the Cloudant database. In this example we use: Three web applications web-app-select (extract domain) web-app-tenant-a (connect to tenant a) web-app-tenant-b (connect to tenant b) Two microservices web-api (react based on given tenant) articles (react based on given tenant) One Identity and Access Management system Keycloak with two custom realms (optional) One database service on IBM Cloud Cloudant with one Database","title":"Architecture"},{"location":"#technologies","text":"The example application currently uses following technologies. Identity and Access Management Keycloak Database Cloudant Multi Tenancy Quarkus Security OpenID Connect Multi Tenancy for the Java microservices implementation Microservies Quarkus Java Web frontends: Vue.js JavaScript Example setup automation Bash","title":"Technologies"},{"location":"#run-the-current-example-locally","text":"","title":"Run the current example locally"},{"location":"#prerequisites","text":"","title":"Prerequisites"},{"location":"#environment","text":"Local OS: Mac OS Visual Studio Code (optional) You need to you have installed on you MacOS: Java: openjdk version \"11.0.11\" Docker Desktop: \"3.4\" Apache Maven: \"3.8.1\" Vue.js: vue/cli \"4.5.13\"","title":"Environment"},{"location":"#steps","text":"You should be able to simply run the example locally.","title":"Steps"},{"location":"#step-1-clone-the-project","text":"git clone https://github.com/thomassuedbroecker/ce-cns-multi-tenant cd ce-cns-multi-tenant/CE","title":"Step 1: Clone the project"},{"location":"#step-2-start-the-example-with-a-bash-script","text":"bash local-start-tenant.sh This bash script will start seven terminals: Keycloak (port 8282) Web-App select (port 8080) Web-App tenant A (port 8081) Web-App tenant B (port 8082) Web-API microservice (port 8083) Articles microservice (port 8084) Auto configuration of Keycloak ( waits 1 min before the configuration starts ) The image below shows the terminal sessions: two browser sessions Web-App select http://localhost:8080/ Keycloak admin http://localhost:8282/ (admin/admin)","title":"Step 2: Start the example with a bash script"},{"location":"#step-3-select-a-tenant-by-inserting-a-email-address-in-the-web-app-select","text":"Use following: alice@blog.de for tenant a alice@blog.com for tenant b","title":"Step 3: Select a tenant by inserting a email address in the Web-App select"},{"location":"#step-4-login-to-tenant-a-or-tenant-b","text":"Use following: User: alice Password: alice","title":"Step 4: Login to tenant a or tenant b"},{"location":"#step-5-logout-from-tenant-a-or-tenant-b","text":"Because this will clear the saved cookie in the browser from Keycloak .","title":"Step 5: Logout from tenant a or tenant b"},{"location":"#step-6-login-to-keycloak-master-realm","text":"Use following: User: admin Password: admin Verify the two realm configurations tenant-a and tenant-b.","title":"Step 6: Login to Keycloak master realm"},{"location":"details-email-domain/","text":"Vue.js \u00b6 Extract email domain in component Tenant.vue of the web-app select . Simple steps: Use of regular expression Lower all cases Split string Verify result Invoke the right web-app for the given tenant Relevant code in Tenant.vue . ... let re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/ ; if ( re . test ( String ( this . emailaddress ). toLowerCase ())){ // Extract tenant var domain = this . emailaddress . split ( \"@\" ); if ( domain . length < 3 ) { // realm tendant A var result = domain [ 1 ]. localeCompare ( \"blog.de\" ); console . log ( \"--> log : result \" , result ); if ( 0 == domain [ 1 ]. localeCompare ( \"blog.de\" )) { // Invoke tenant web-app console . log ( \"--> log : tenant \" , domain [ 1 ]); console . log ( \"--> log : A \" , window . VUE_TENANT_A ); window . open ( window . VUE_TENANT_A , \"Tenant A\" ); this . $forceUpdate (); this . emailaddress = \"\" ; this . errormessage = \"\" ; ...","title":"Vue.js extract domain from email"},{"location":"details-email-domain/#vuejs","text":"Extract email domain in component Tenant.vue of the web-app select . Simple steps: Use of regular expression Lower all cases Split string Verify result Invoke the right web-app for the given tenant Relevant code in Tenant.vue . ... let re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/ ; if ( re . test ( String ( this . emailaddress ). toLowerCase ())){ // Extract tenant var domain = this . emailaddress . split ( \"@\" ); if ( domain . length < 3 ) { // realm tendant A var result = domain [ 1 ]. localeCompare ( \"blog.de\" ); console . log ( \"--> log : result \" , result ); if ( 0 == domain [ 1 ]. localeCompare ( \"blog.de\" )) { // Invoke tenant web-app console . log ( \"--> log : tenant \" , domain [ 1 ]); console . log ( \"--> log : A \" , window . VUE_TENANT_A ); window . open ( window . VUE_TENANT_A , \"Tenant A\" ); this . $forceUpdate (); this . emailaddress = \"\" ; this . errormessage = \"\" ; ...","title":"Vue.js"},{"location":"details-quarkus-extract-tenant/","text":"Extract tenant and reconfigure OIDC configuration with Quarkus for Keycloak \u00b6 This implementation detail is structured in objective, use case definition, architecture, multi tenancy realization, technologies, and implementation.\u00b6 Objective\u00b6 \u00b6 I want to start with a very simple microservices based application example for multi tenancy implementation, and for this application is a simple use case defined. The starting point, from the technical and usage perspective, is this workshop Get started to deploy a Java Microservices application to Code Engine . Use Case definition \u00b6 Show articles based on an email domain, validated by role and user authentication and authorization. Basic Flow \u00b6 Insert email address Based on the domain of your email address you are routed to the right tenant (example blog.de and blog.com ) Login to the right realm on the Identity and Access Management system The articles are displayed according to the user role and tenant. The following gif shows an example implementation overview of this use case on the local machine. Architecture \u00b6 The gif shows a simplified overview of the dependencies of the architecture in following sequence: Invoke web-app-select on port 8080 and insert your email to select the domain for the tenant ((blog.de == tenantA) and (blog.com == tenantA)) The related webfrontend for blog.de is invoked, it's web-app-tenant-a ( port 8081 ) that redirects to the right Keycloak realm (tenant-A) which provides the login and returns the access-token. We use that token to access the web-api microservice ( port 8083 ). Therefor we invoke the web-api REST endpoint related to the right tenant (realm), in this case it's tenant-a. ( user:alice;role:user in both realms) The microservice web-api uses the the functionalities for multitenancy provided by Quarkus security openID connect multitenancy to extract the invoked endpoint from the rootcontext and set the right configuration for the given tenant, that means in this case for the Keycloak realm . Quarkus also does the validation of the access token at right Keycloak realm and forwards the given access-token to the microservice articles, by using the right REST endpoint for the given tenant. The articles microservice does the same validation as web-api using Quarkus and uses the right query to provide the needed articles data from the Cloudant database. Multi tenancy realization \u00b6 In the given use case following multi tenancy realization will be used. Variable frontends for each domain Microservice using Quarkus Security OpenID Connect Multi Tenancy Database will have an additional entry to separate the domains Identity and access management will be managed by different Keycloak realms Technologies \u00b6 The example application currently uses following technologies. Identity and Access Management ( Keycloak ) Multi Tenancy ( Quarkus Security OpenID Connect Multi Tenancy ) Microservices ( Quarkus ) Web frontend Vue.js (Web frontend with JavaScript) (Optional a Database) Cloudant Implementation \u00b6 The Quarkus Security OpenID Connect Multi Tenancy for the multi tenancy of the java microservices is used for the implementation. Here we focus only on the example implementation for the web-api microservice. These are the steps: Provide a REST endpoint for each tenant Extract the invoked endpoint from the rootcontext and set the right configuration in the CustomTenantConfigResolver class for the given tenant, that means in this case for the Keycloak realm . Based on the known tenant invoke the right endpoint of the articles service . Create REST client for each tenant Invoke the right client Provide REST endpoint for each tenant \u00b6 Relevant code in ArticleResource.java of the web-api service. In this case these are the two endpoints: @Path(\"/articlesA\") @Path(\"/articlesB\") @GET @Path ( \"/articlesA\" ) @Produces ( MediaType . APPLICATION_JSON ) //@Authenticated @RolesAllowed ( \"user\" ) @NoCache public List < Article > getArticlesA () { try { List < CoreArticle > coreArticles = articlesDataAccess . getArticles ( 5 ); System . out . println ( \"-->log: com.ibm.webapi.ArticleResource.getArticles -> articlesDataAccess.getArticles\" ); return createArticleList ( coreArticles ); } catch ( NoConnectivity e ) { System . err . println ( \"-->log: com.ibm.webapi.ArticleResource.getArticles: Cannot connect to articles service\" ); throw new NoDataAccess ( e ); } } @GET @Path ( \"/articlesB\" ) @Produces ( MediaType . APPLICATION_JSON ) //@Authenticated @RolesAllowed ( \"user\" ) @NoCache public List < Article > getArticlesB () { try { List < CoreArticle > coreArticles = articlesDataAccess . getArticles ( 5 ); System . out . println ( \"-->log: com.ibm.webapi.ArticleResource.getArticles -> articlesDataAccess.getArticles\" ); return createArticleList ( coreArticles ); } catch ( NoConnectivity e ) { System . err . println ( \"-->log: com.ibm.webapi.ArticleResource.getArticles: Cannot connect to articles service\" ); throw new NoDataAccess ( e ); } } Extract the invoked endpoint and set the right configuration in the CustomTenantConfigResolver\u00b6 \u00b6 Extract the invoked endpoint from the rootcontext and set the right configuration in the CustomTenantConfigResolver class for the given tenant, that means in this case for the Keycloak realm . Relevant code in CustomTenantConfigResolver.java of the web-api microservice . package com.ibm.webapi ; import javax.enterprise.context.ApplicationScoped ; // Tenant import io.quarkus.oidc.TenantConfigResolver ; import io.quarkus.oidc.OidcTenantConfig ; import io.vertx.ext.web.RoutingContext ; @ApplicationScoped public class CustomTenantConfigResolver implements TenantConfigResolver { @Override public OidcTenantConfig resolve ( RoutingContext context ) { System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve : \" + // 1. Extract path context . request (). path ()); String path = context . request (). path (); String [] parts = path . split ( \"/\" ); if ( parts . length == 0 ) { // resolve to default tenant configuration return null ; } // 2. Verify path with given tenant options if ( \"articlesA\" . equals ( parts [ 1 ] )) { OidcTenantConfig config = new OidcTenantConfig (); System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve A: \" + config . getToken (). getIssuer (). toString ()); // 3. Set the right configuration for the Keycloak realm config . setTenantId ( \"tenantA\" ); config . setAuthServerUrl ( \"http://localhost:8282/auth/realms/tenantA\" ); config . setClientId ( \"backend-service\" ); OidcTenantConfig . Credentials credentials = new OidcTenantConfig . Credentials (); credentials . setSecret ( \"secret\" ); config . setCredentials ( credentials ); System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve A: \" + config . toString ()); return config ; } if ( \"articlesB\" . equals ( parts [ 1 ] )) { System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve\" ); OidcTenantConfig config = new OidcTenantConfig (); System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve issuer: \" + config . getToken (). getIssuer (). toString ()); config . setTenantId ( \"tenantB\" ); config . setAuthServerUrl ( \"http://localhost:8282/auth/realms/tenantB\" ); config . setClientId ( \"backend-service\" ); OidcTenantConfig . Credentials credentials = new OidcTenantConfig . Credentials (); credentials . setSecret ( \"secret\" ); config . setCredentials ( credentials ); System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve B: \" + config . toString ()); return config ; } return null ; } } Based on the known tenant invoke the right endpoint of the articles service \u00b6 Now we can invoke articles microservice, which is implemented in the same way. 1. Create REST client for each tenant \u00b6 Relevant code in ArticlesDataAccess.java of the web-api service. URI apiV1 = null ; apiV1 = UriBuilder . fromUri ( articles_url_tenant_A ). build (); System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.initialize URI (tenantA) : \" + apiV1 . toString ()); articlesServiceA = RestClientBuilder . newBuilder () . baseUri ( apiV1 ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class ); apiV1 = UriBuilder . fromUri ( articles_url_tenant_B ). build (); System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.initialize URI (tenantB) : \" + apiV1 . toString ()); articlesServiceB = RestClientBuilder . newBuilder () . baseUri ( apiV1 ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class ); Invoke the right client \u00b6 Relevant code in ArticlesDataAccess.java of the web-api service. String tenant = tenantJSONWebToken (); System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.getArticles (tenant): \" + tenant ); if ( \"tenantA\" . equals ( tenant )){ System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.getArticles \" + tenant ); return articlesServiceA . getArticlesFromService ( amount ); } if ( \"tenantB\" . equals ( tenant )){ System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.getArticles \" + tenant ); return articlesServiceB . getArticlesFromService ( amount ); } else { System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.getArticles(NO TENANT)\" ); return null ; }","title":"Quakus extract tenant and reconfigure OIDC configuration"},{"location":"details-quarkus-extract-tenant/#extract-tenant-and-reconfigure-oidc-configuration-with-quarkus-for-keycloak","text":"This implementation detail is structured in objective, use case definition, architecture, multi tenancy realization, technologies, and implementation.\u00b6","title":"Extract tenant and reconfigure OIDC configuration with Quarkus for Keycloak"},{"location":"details-quarkus-extract-tenant/#objective","text":"I want to start with a very simple microservices based application example for multi tenancy implementation, and for this application is a simple use case defined. The starting point, from the technical and usage perspective, is this workshop Get started to deploy a Java Microservices application to Code Engine .","title":"Objective\u00b6"},{"location":"details-quarkus-extract-tenant/#use-case-definition","text":"Show articles based on an email domain, validated by role and user authentication and authorization.","title":"Use Case definition"},{"location":"details-quarkus-extract-tenant/#basic-flow","text":"Insert email address Based on the domain of your email address you are routed to the right tenant (example blog.de and blog.com ) Login to the right realm on the Identity and Access Management system The articles are displayed according to the user role and tenant. The following gif shows an example implementation overview of this use case on the local machine.","title":"Basic Flow"},{"location":"details-quarkus-extract-tenant/#architecture","text":"The gif shows a simplified overview of the dependencies of the architecture in following sequence: Invoke web-app-select on port 8080 and insert your email to select the domain for the tenant ((blog.de == tenantA) and (blog.com == tenantA)) The related webfrontend for blog.de is invoked, it's web-app-tenant-a ( port 8081 ) that redirects to the right Keycloak realm (tenant-A) which provides the login and returns the access-token. We use that token to access the web-api microservice ( port 8083 ). Therefor we invoke the web-api REST endpoint related to the right tenant (realm), in this case it's tenant-a. ( user:alice;role:user in both realms) The microservice web-api uses the the functionalities for multitenancy provided by Quarkus security openID connect multitenancy to extract the invoked endpoint from the rootcontext and set the right configuration for the given tenant, that means in this case for the Keycloak realm . Quarkus also does the validation of the access token at right Keycloak realm and forwards the given access-token to the microservice articles, by using the right REST endpoint for the given tenant. The articles microservice does the same validation as web-api using Quarkus and uses the right query to provide the needed articles data from the Cloudant database.","title":"Architecture"},{"location":"details-quarkus-extract-tenant/#multi-tenancy-realization","text":"In the given use case following multi tenancy realization will be used. Variable frontends for each domain Microservice using Quarkus Security OpenID Connect Multi Tenancy Database will have an additional entry to separate the domains Identity and access management will be managed by different Keycloak realms","title":"Multi tenancy realization"},{"location":"details-quarkus-extract-tenant/#technologies","text":"The example application currently uses following technologies. Identity and Access Management ( Keycloak ) Multi Tenancy ( Quarkus Security OpenID Connect Multi Tenancy ) Microservices ( Quarkus ) Web frontend Vue.js (Web frontend with JavaScript) (Optional a Database) Cloudant","title":"Technologies"},{"location":"details-quarkus-extract-tenant/#implementation","text":"The Quarkus Security OpenID Connect Multi Tenancy for the multi tenancy of the java microservices is used for the implementation. Here we focus only on the example implementation for the web-api microservice. These are the steps: Provide a REST endpoint for each tenant Extract the invoked endpoint from the rootcontext and set the right configuration in the CustomTenantConfigResolver class for the given tenant, that means in this case for the Keycloak realm . Based on the known tenant invoke the right endpoint of the articles service . Create REST client for each tenant Invoke the right client","title":"Implementation"},{"location":"details-quarkus-extract-tenant/#provide-rest-endpoint-for-each-tenant","text":"Relevant code in ArticleResource.java of the web-api service. In this case these are the two endpoints: @Path(\"/articlesA\") @Path(\"/articlesB\") @GET @Path ( \"/articlesA\" ) @Produces ( MediaType . APPLICATION_JSON ) //@Authenticated @RolesAllowed ( \"user\" ) @NoCache public List < Article > getArticlesA () { try { List < CoreArticle > coreArticles = articlesDataAccess . getArticles ( 5 ); System . out . println ( \"-->log: com.ibm.webapi.ArticleResource.getArticles -> articlesDataAccess.getArticles\" ); return createArticleList ( coreArticles ); } catch ( NoConnectivity e ) { System . err . println ( \"-->log: com.ibm.webapi.ArticleResource.getArticles: Cannot connect to articles service\" ); throw new NoDataAccess ( e ); } } @GET @Path ( \"/articlesB\" ) @Produces ( MediaType . APPLICATION_JSON ) //@Authenticated @RolesAllowed ( \"user\" ) @NoCache public List < Article > getArticlesB () { try { List < CoreArticle > coreArticles = articlesDataAccess . getArticles ( 5 ); System . out . println ( \"-->log: com.ibm.webapi.ArticleResource.getArticles -> articlesDataAccess.getArticles\" ); return createArticleList ( coreArticles ); } catch ( NoConnectivity e ) { System . err . println ( \"-->log: com.ibm.webapi.ArticleResource.getArticles: Cannot connect to articles service\" ); throw new NoDataAccess ( e ); } }","title":"Provide  REST endpoint for each tenant"},{"location":"details-quarkus-extract-tenant/#extract-the-invoked-endpoint-and-set-the-right-configuration-in-the-customtenantconfigresolver","text":"Extract the invoked endpoint from the rootcontext and set the right configuration in the CustomTenantConfigResolver class for the given tenant, that means in this case for the Keycloak realm . Relevant code in CustomTenantConfigResolver.java of the web-api microservice . package com.ibm.webapi ; import javax.enterprise.context.ApplicationScoped ; // Tenant import io.quarkus.oidc.TenantConfigResolver ; import io.quarkus.oidc.OidcTenantConfig ; import io.vertx.ext.web.RoutingContext ; @ApplicationScoped public class CustomTenantConfigResolver implements TenantConfigResolver { @Override public OidcTenantConfig resolve ( RoutingContext context ) { System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve : \" + // 1. Extract path context . request (). path ()); String path = context . request (). path (); String [] parts = path . split ( \"/\" ); if ( parts . length == 0 ) { // resolve to default tenant configuration return null ; } // 2. Verify path with given tenant options if ( \"articlesA\" . equals ( parts [ 1 ] )) { OidcTenantConfig config = new OidcTenantConfig (); System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve A: \" + config . getToken (). getIssuer (). toString ()); // 3. Set the right configuration for the Keycloak realm config . setTenantId ( \"tenantA\" ); config . setAuthServerUrl ( \"http://localhost:8282/auth/realms/tenantA\" ); config . setClientId ( \"backend-service\" ); OidcTenantConfig . Credentials credentials = new OidcTenantConfig . Credentials (); credentials . setSecret ( \"secret\" ); config . setCredentials ( credentials ); System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve A: \" + config . toString ()); return config ; } if ( \"articlesB\" . equals ( parts [ 1 ] )) { System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve\" ); OidcTenantConfig config = new OidcTenantConfig (); System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve issuer: \" + config . getToken (). getIssuer (). toString ()); config . setTenantId ( \"tenantB\" ); config . setAuthServerUrl ( \"http://localhost:8282/auth/realms/tenantB\" ); config . setClientId ( \"backend-service\" ); OidcTenantConfig . Credentials credentials = new OidcTenantConfig . Credentials (); credentials . setSecret ( \"secret\" ); config . setCredentials ( credentials ); System . out . println ( \"-->log: com.ibm.web-api.CustomTenantResolver.resolve B: \" + config . toString ()); return config ; } return null ; } }","title":"Extract the invoked endpoint and set the right configuration in the CustomTenantConfigResolver\u00b6"},{"location":"details-quarkus-extract-tenant/#based-on-the-known-tenant-invoke-the-right-endpoint-of-the-articles-service","text":"Now we can invoke articles microservice, which is implemented in the same way.","title":"Based on the known tenant invoke the right endpoint of the articles service"},{"location":"details-quarkus-extract-tenant/#1-create-rest-client-for-each-tenant","text":"Relevant code in ArticlesDataAccess.java of the web-api service. URI apiV1 = null ; apiV1 = UriBuilder . fromUri ( articles_url_tenant_A ). build (); System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.initialize URI (tenantA) : \" + apiV1 . toString ()); articlesServiceA = RestClientBuilder . newBuilder () . baseUri ( apiV1 ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class ); apiV1 = UriBuilder . fromUri ( articles_url_tenant_B ). build (); System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.initialize URI (tenantB) : \" + apiV1 . toString ()); articlesServiceB = RestClientBuilder . newBuilder () . baseUri ( apiV1 ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class );","title":"1. Create REST client for each tenant"},{"location":"details-quarkus-extract-tenant/#invoke-the-right-client","text":"Relevant code in ArticlesDataAccess.java of the web-api service. String tenant = tenantJSONWebToken (); System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.getArticles (tenant): \" + tenant ); if ( \"tenantA\" . equals ( tenant )){ System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.getArticles \" + tenant ); return articlesServiceA . getArticlesFromService ( amount ); } if ( \"tenantB\" . equals ( tenant )){ System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.getArticles \" + tenant ); return articlesServiceB . getArticlesFromService ( amount ); } else { System . out . println ( \"-->log: com.ibm.web-api.ArticlesDataAccess.getArticles(NO TENANT)\" ); return null ; }","title":"Invoke the right client"},{"location":"lab-tbd/","text":"UNDER CONSTRUCTION \u00b6 TBD","title":"1. TBD"},{"location":"lab-tbd/#under-construction","text":"TBD","title":"UNDER CONSTRUCTION"},{"location":"optional-lab-tbd/","text":"UNDER CONSTRUCTION \u00b6 TBD","title":"1. TBD"},{"location":"optional-lab-tbd/#under-construction","text":"TBD","title":"UNDER CONSTRUCTION"}]}